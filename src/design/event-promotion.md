# Event Promotion Design: State-Based Reconciliation with Composite Keys

## Overview
Traditional event sourcing replication involves copying raw events from one environment to another. However, this fails when the target environment has diverged (e.g., hotfixes), causing `aggregateVersion` conflicts. Additionally, strict global UUID constraints can prevent reusing the same ID across environments (Tenants). Finally, partial promotions can fail if parent dependencies (referential integrity) are missing in the target.

To resolve this, we adopt a **State-Based Reconciliation** approach (Semantic Replay) combined with **Composite Keys** for identity and **Recursive Dependency Resolution** for integrity.

## Core Strategy: State-Based Reconciliation

### Workflow
1.  **Export (Lower Environment):**
    *   Query the *current state* (Snapshot) of the entity from the Lower Environment (LE).
    *   Produce a "Canonical State Snapshot" (JSON).
2.  **Import & Diff (Higher Environment):**
    *   Read the LE Snapshot.
    *   Query the *current* state of the representative entity in the Higher Environment (HE).
    *   **Compare:**
        *   **New?** -> Generate `XxxCreatedEvent`.
        *   **Changed?** -> Calculate Delta -> Generate `XxxUpdatedEvent`.
        *   **Same?** -> No-op.

### Advantages
*   **Conflict Immunity:** No `aggregateVersion` conflicts; we always append *new* events.
*   **Self-Healing:** Automatically synchronizes diverged states.

## Identity Strategy: Composite Keys

### The Problem: Global UUID Uniqueness
In a multi-tenant system shareing a single database, a standard Primary Key `UUID` (e.g., `user_id`) is globally unique. This prevents us from having "User Steve" with UUID `123` in both the "Dev Tenant" and "Prod Tenant" if the DB enforces strict uniqueness on that column.

### The Solution: Composite Keys (`host_id` + `aggregate_id`)
We scope all identity by the Tenant ID (`host_id`).

1.  **Schema Change:**
    *   **Primary Keys:** Change from `PK(id)` to `PK(host_id, id)`.
    *   **Uniqueness:** Change unique constraints (e.g., email) from `UK(email)` to `UK(host_id, email)`.
    *   **Event Store:** Change unique constraint from `UK(aggregate_id, version)` to `UK(host_id, aggregate_id, version)`.

2.  **Promotion Benefit:**
    *   **Dev Tenant:** `host_id=DEV, user_id=123`
    *   **Prod Tenant:** `host_id=PROD, user_id=123`
    *   Matching entities is trivial (compare `id` directly).

## Data Integrity: Recursive Dependency Resolution

### The Problem: Missing Dependencies
Promoting a child entity (e.g., **API Configuration**) fails if its parent (e.g., **API Instance**) does not exist in the target environment (Higher Env).

### The Solution: Deep Promotion (Recursive Bundling)
The exporter must be "Topology Aware".

1.  **Dependency Metadata:**
    Every Entity Type must declare its dependencies.
    *   `ApiConfig` depends on `ApiInstance`.
    *   `ApiInstance` depends on `GatewayInstance`.
    *   `GatewayInstance` depends on `Host`.

2.  **Export Workflow (Recursive):**
    When a user selects `ApiConfig-123` for promotion:
    *   System checks `ApiConfig-123` -> Parent `ApiInstance-456`.
    *   System checks `ApiInstance-456` -> Parent `GatewayInstance-789`.
    *   **Export Package:** Includes `[GatewayInstance-789, ApiInstance-456, ApiConfig-123]` (Ordered by dependency).

3.  **Import Workflow (Ordered):**
    The Importer processes the list in order:
    1.  **GatewayInstance:** Exists in Prod? Yes. (Skip).
    2.  **ApiInstance:** Exists in Prod? No. **Action: Create `ApiInstance`**.
    3.  **ApiConfig:** Exists in Prod? No. **Action: Create `ApiConfig`**.

## Dry Run Technical Implementation

### Purpose
To guarantee the promotion will succeed without actually modifying the Higher Environment (Production).

### Option 1: Application-Layer Simulation (Fast, Recommended for Planning)
*   **Logic:** The Importer queries the DB (read-only) to fetch the current state of all entities in the package.
*   **Result:** It calculates the "Diff Plan" purely in memory.
*   **Output:** "Plan: Create API Instance (New), Update API Config (Diff)".
*   **Pros:** Very fast, zero DB locks.
*   **Cons:** Does not verify deep database constraints (e.g., complex triggers or check constraints) that only trigger on write.

### Option 2: Transaction Rollback (Robust, Recommended for Validation)
*   **Logic:**
    1.  Start a Database Transaction: `connection.setAutoCommit(false);`
    2.  **Simulate Execution:** Perform the actual SQL Inserts and Updates generated by the Plan.
        *   Insert `ApiInstance`...
        *   Insert `ApiConfig`...
    3.  **Check for Errors:** If any SQL Exception occurs (e.g., FK violation, unique constraint violation), catch it.
    4.  **Rollback:** Regardless of success or failure, **always** call `connection.rollback()`.
*   **Output:** "Validation Successful: The detailed plan is valid and safe to execute." OR "Validation Failed: FK Violation on Table X".
*   **Pros:** 100% certainty that the data is valid according to the database schema.
*   **Cons:** Slightly heavier key locks, but acceptable for admin operations.

### Recommendation
Use **Option 1 (App Simulation)** for the UI preview to show the user "what will happen".
Use **Option 2 (Transaction Rollback)** immediately when the user clicks "Promote" (as a pre-flight check) or as an explicit "Verify" button to ensure deep integrity.

## Sibling Deletion: Handling Orphaned Items

### The User Case
When promoting a collection of items (e.g., "10 Config Properties" in HE vs "8 in LE"), simply creating or updating the 8 matching items from LE is insufficient. We must identify the **2 extra items** in HE that likely need to be deleted to match the LE state.

### Design Pattern: Scoped Reconciliation
To handle this, the import logic must be aware of the "Parent Scope" of the entities being promoted.

1.  **Export (Snapshot with Siblings):**
    *   When promoting `ApiConfig-123`, we fetch **ALL** associated properties for that config in LE.
    *   LE Snapshot: `Properties = {P1, P2, ... P8}` (Total 8).

2.  **Import (Set Difference Logic):**
    *   Query **ALL** associated properties for `ApiConfig-123` in HE.
    *   HE State: `Properties = {P1, P2, ... P8, P9, P10}` (Total 10).
    *   **Logic:** `HE_Only = HE_Set - LE_Set` => `{P9, P10}`.

3.  **User Decision (Interactive Mode):**
    *   The Dry Run Plan reports:
        *   `Updates:` 8 items synced (P1..P8).
        *   `Deuntions (Potential):` 2 items exist in Prod but not Dev (P9, P10).
    *   **Default Action:** Do nothing (Safe Mode).
    *   **Option:** "Sync Deletes" -> Checkbox to delete extras?
    *   **Strict Mode:** Mirror exact state (Automatically schedule `ConfigPropertyDeletedEvent` for P9, P10).

### Implementation Checklist
- [ ] Exporter must include the full list of children IDs when exporting a parent container.
- [ ] Importer must realize that for "One-to-Many" relationships, it has to fetch the full target set to detect orphans.
